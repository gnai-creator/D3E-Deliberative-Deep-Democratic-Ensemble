# 🧠 GrampyX: Neural Deliberative Court

GrampyX is a symbolic architecture inspired by judicial systems, designed to solve problems through collaborative learning, with multiple neural agents performing distinct institutional roles.

---

## 🎯 Objective

Simulate deliberation, conflict, and consensus among multiple neural models on tasks such as the ARC Challenge, modeling decision-making, trust, and authority.

---

## 👥 Institutional Structure

* **Advocate**: initiates the thesis (prediction) based on the raw input. Trained with feedback from the Judge.
* **Jurors 0, 1, 2**:

  * **Juror 0**: has spatial behavioral noise (DropBlock)
  * **Juror 1**: loyal to the advocate
  * **Juror 2**: possesses "theory of mind": follows the advocate but adjusts if diverging from the Supreme
* **Judge**: judges based on jurors and the advocate; learns from Supreme feedback
* **Supreme Judge**: final authority; learns from all and validates the consensus
* **Prosecutor**: challenges the Supreme by proposing an antithesis; adds dialectical tension to improve generalization.

---

## 🔁 Deliberation Cycle

1. **Initial Phase**:

   * Jurors 0–4 predict on training data (X\_train).
   * Their predictions are filtered to match valid output classes.

2. **Supreme Phase**:

   * Supreme aggregates predictions (jurors + judge + advocate) to form a symbolic consensus (mode).
   * Supreme is trained on this consensus.

3. **Prosecutor Phase**:

   * Antithesis is generated by inverting the consensus.
   * Prosecutor is trained on the antithesis.

4. **Evaluation Phase**:

   * Jurors 1–4, Supreme, and Prosecutor predict on test data (X\_test).
   * After half the max iterations, Juror 0 updates its prediction on X\_train to match Supreme feedback.

5. **Retraining Phase**:

   * If Juror 0's prediction diverges significantly from Supreme's consensus, it is retrained on recolored consensus.

6. **Consensus Evaluation**:

   * A weighted symbolic consensus is calculated.
   * If the tolerance is met, deliberation ends and Supreme's output is returned.
   * Otherwise, the loop continues for max\_cycles.

---

## 📈 Trust and Evaluation

* Each agent has a **symbolic trust score** based on its agreement with the Supreme.
* An **adaptive trust system** penalizes models that frequently diverge from the final consensus.

---

## 🧪 Application: ARC Challenge

* Input: symbolic grid from ARC (e.g., `(1, 30, 30, 1, 1)`)
* Output: per-pixel class prediction
* Final consensus is defined by the Supreme Judge
* Metrics for divergence, entropy, and trust are recorded at each iteration

---

## 🧬 Philosophy

GrampyX is not just an ensemble — it's a simulation of a **symbolic deliberative system** with autonomous agents learning under authority, noise, and cognitive conflict.

> "Justice is not immediate consensus, but the struggle for understanding through multiple perspectives."

---

## 🚀 Scalability

GrampyX is designed with modularity and extensibility in mind. It can be applied in both individual model setups and collective multi-agent systems:

* **Individual Mode**: A single agent (e.g., the Advocate or Supreme Judge) can be used for symbolic prediction, reasoning diagnostics, or as a pre-trained symbolic encoder in other workflows.
* **Collective Mode**: All agents operate in a full deliberative court, exchanging symbolic knowledge iteratively. Ideal for tasks requiring consensus and agent interaction, such as the ARC Challenge in full block mode.

Additional features:

* Agents can be swapped, extended, or fine-tuned independently.
* Supports more jurors or additional roles (e.g., revisors, auditors).
* Symbolic state and trust logic are decoupled from network architecture.
* Easily adapted to new symbolic tasks beyond ARC, including visual logic puzzles or symbolic reasoning games.

---

## 🛠️ Requirements

* TensorFlow 2.14+
* Numpy, Matplotlib, Seaborn
* Python 3.10+

---

## 📁 Core Structure

* `GrampyX.py` — main execution
* `court_logic.py` — deliberation logic
* `confidence_system.py` — symbolic trust system
* `metrics_utils.py` — visualizations and analysis
* `court_utils.py` — utility functions for class extraction and preprocessing
* `SimuV*.py` — neural model definitions by role

---

## 📜 License

This project is protected from commercial use until official royalty release. See the repository license for more information.
